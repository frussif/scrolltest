<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Scroll Tracker</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    #log {
      white-space: pre-line;
      font-family: monospace;
      background: #f4f4f4;
      padding: 10px;
      border-radius: 5px;
      max-width: 600px;
      margin: auto;
      text-align: left;
    }
    #chartContainer {
      margin-top: 20px;
      position: relative;
    }
    canvas {
      border: 1px solid #ccc;
    }
    #intervalHistory {
      margin-top: 20px;
      padding: 10px;
      background: #fafafa;
      border: 1px solid #ccc;
      border-radius: 5px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      font-family: monospace;
      text-align: left;
    }
    #intervalHistory h3 {
      margin-top: 0;
      margin-bottom: 8px;
    }
    #historyContent {
      max-height: 10.5em; /* ~10 lines */
      overflow-y: auto;
      white-space: pre-line;
      line-height: 1.3em;
    }
    #resetBtn {
      margin-top: 10px;
      padding: 6px 10px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Scroll Tracker</h1>
  <p>Start scrolling to track your activity!</p>
  <div id="log">Waiting for scroll input...</div>
  <div id="chartContainer">
    <canvas id="scrollChart" width="600" height="300"></canvas>
  </div>

  <div id="intervalHistory">
    <h3>Interval history</h3>
    <div id="historyContent">No results yet...</div>
    <button id="resetBtn" type="button">Reset history</button>
  </div>

  <script>
    class ScrollTracker {
      constructor() {
        this.reset();
        this.trackingActive = false;
        this.initListeners();
        this.initGraph();
        this.initReset();
      }

      reset() {
        this.scrollCount = 0;
        this.startTime = null;
        this.lastScrollTime = null;
        this.scrollTimes = [];
        this.scrollIntervals = [];
        this.scrollDirections = []; // "up" or "down" per event
        this.majorityDirection = null; // decided per session in analyze
        this.trackingActive = false;
        this.inconsistentScrolls = 0;
      }

      initListeners() {
        document.addEventListener("wheel", (event) => this.onScroll(event));
      }

      initReset() {
        document.getElementById("resetBtn").addEventListener("click", () => {
          document.getElementById("historyContent").innerHTML = "No results yet...";
        });
      }

      onScroll(event) {
        const currentTime = performance.now();
        const direction = event.deltaY > 0 ? "down" : "up";

        if (this.scrollTimes.length > 0) {
          this.scrollIntervals.push(currentTime - this.scrollTimes[this.scrollTimes.length - 1]);
        }

        this.scrollCount++;
        this.scrollTimes.push(currentTime);
        this.scrollDirections.push(direction);

        if (!this.trackingActive) {
          this.trackingActive = true;
          this.startTime = currentTime;
        }

        this.lastScrollTime = currentTime;
        this.updateLog(`Scroll detected: ${this.scrollCount} scrolls`);

        setTimeout(() => this.analyzeScrollActivity(), 100);
      }

      calculateScrollRate() {
        if (this.startTime && this.lastScrollTime) {
          const duration = (this.lastScrollTime - this.startTime) / 1000;
          return duration > 0 ? (this.scrollCount / duration).toFixed(2) : 0;
        }
        return 0;
      }

      decideMajorityDirection() {
        const upCount = this.scrollDirections.filter(d => d === "up").length;
        const downCount = this.scrollDirections.filter(d => d === "down").length;
        this.majorityDirection = upCount >= downCount ? "up" : "down";
      }

      isOppositeInterval(index) {
        // interval i corresponds to event i+1 direction
        const dir = this.scrollDirections[index + 1];
        return this.majorityDirection && dir && dir !== this.majorityDirection;
      }

      analyzeScrollActivity() {
        if (!this.trackingActive || performance.now() - this.lastScrollTime < 100) return;

        this.decideMajorityDirection();

        const durationMs = (this.lastScrollTime - this.startTime).toFixed(0);
        const scrollRate = this.calculateScrollRate();
        const intervalAnalysis = this.analyzeScrollIntervals();

        this.updateLog(
          `\nTotal scrolls: ${this.scrollCount}` +
          `\nTotal scroll time: ${durationMs} ms` +
          `\nScroll rate: ${scrollRate} scrolls per second` +
          `\n${intervalAnalysis}` +
          `\n\nStart scrolling again to begin a new measurement.`
        );

        const historyDiv = document.getElementById("historyContent");
        const line = this.formatIntervalsLineColored();
        if (line) {
          if (historyDiv.innerHTML === "No results yet...") {
            historyDiv.innerHTML = line;
          } else {
            historyDiv.innerHTML = line + "\n" + historyDiv.innerHTML;
          }
        }

        this.updateGraph();
        this.trackingActive = false;
        this.reset();
      }

      analyzeScrollIntervals() {
        if (this.scrollIntervals.length < 2) return "Not enough scrolls to analyze timing.";

        const trimmedIntervals = this.scrollIntervals.slice(0, -2);
        const lastTwo = this.scrollIntervals.slice(-2);

        const averageInterval =
          trimmedIntervals.reduce((sum, interval) => sum + interval, 0) /
          Math.max(1, trimmedIntervals.length);

        this.inconsistentScrolls = trimmedIntervals.filter(
          (interval) => interval < 10 || interval > 30
        ).length;

        const formattedIntervals = trimmedIntervals
          .map((interval, i) => {
            const idx = i; // index within full intervals
            const val = interval.toFixed(0) + "ms";
            const colored =
              interval < 10 ? `<span style="color:red;">${val}</span>` :
              interval > 30 ? `<span style="color:orange;">${val}</span>` :
              val;
            return this.isOppositeInterval(idx)
              ? `<s>${colored}</s>`
              : colored;
          })
          .join(", ");

        const lastTwoFormatted = lastTwo
          .map((interval, i) => {
            const idx = this.scrollIntervals.length - 2 + i;
            const val = interval.toFixed(0) + "ms";
            const colored =
              interval < 10 ? `<span style="color:orange;">${val}</span>` : // keep distinct from main list
              interval > 30 ? `<span style="color:orange;">${val}</span>` :
              val;
            return this.isOppositeInterval(idx)
              ? `<s>${colored}</s>`
              : colored;
          })
          .join(", ");

        return (
          `Scroll Intervals (ms): ${formattedIntervals}` +
          `\nLast 2 intervals (excluded from graph): ${lastTwoFormatted}` +
          `\nMajority direction: ${this.majorityDirection}` +
          `\nScrolls are ${
            this.inconsistentScrolls === 0
              ? "consistent"
              : "<span style='color: red;'>inconsistent</span>"
          }` +
          `\nAvg interval: ${averageInterval.toFixed(0)}ms`
        );
      }

      formatIntervalsLineColored() {
        if (this.scrollIntervals.length < 2) return "";

        return this.scrollIntervals.map((interval, i) => {
          const val = interval.toFixed(0); // plain number for history
          let colored =
            interval < 10 ? `<span style="color:red;">${val}</span>` :
            interval > 25 ? `<span style="color:orange;">${val}</span>` :
            val;

          if (this.isOppositeInterval(i)) {
            colored = `<s>${colored}</s>`;
          }

          return colored;
        }).join(", ");
      }

      updateLog(message) {
        document.getElementById("log").innerHTML = message;
      }

      initGraph() {
        this.canvas = document.getElementById("scrollChart");
        this.ctx = this.canvas.getContext("2d");
      }

      drawStrikethroughText(text, x, y) {
        // Draw text, then a strike line through its middle
        this.ctx.fillText(text, x, y);
        const metrics = this.ctx.measureText(text);
        const textWidth = metrics.width;
        const lineY = y - 6; // adjust to cut through text visually
        this.ctx.beginPath();
        this.ctx.moveTo(x, lineY);
        this.ctx.lineTo(x + textWidth, lineY);
        this.ctx.stroke();
      }

      updateGraph() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Exclude last two intervals from the graph as per your logic
        const graphData = this.scrollIntervals.slice(0, -2);
        if (graphData.length < 2) {
          // Still draw axes and labels to avoid "freeze" sensation
          const padding = 40;
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding, padding);
          ctx.lineTo(padding, canvas.height - padding);
          ctx.lineTo(canvas.width - padding, canvas.height - padding);
          ctx.stroke();

          ctx.fillStyle = "black";
          ctx.font = "14px Arial";
          ctx.fillText("Interval Number", canvas.width / 2 - 40, canvas.height - 10);
          ctx.fillText("Scroll Interval (ms)", 10, 20);
          return;
        }

        const maxInterval = Math.max(...graphData);
        const padding = 40;

        // Axes
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding, canvas.height - padding);
        ctx.stroke();

        // Labels
        ctx.fillStyle = "black";
        ctx.font = "14px Arial";
        ctx.fillText("Interval Number", canvas.width / 2 - 40, canvas.height - 10);
        ctx.fillText("Scroll Interval (ms)", 10, 20);

        // X tick labels
        graphData.forEach((_, index) => {
          const x = padding + (index * ((canvas.width - padding * 2) / graphData.length));
          ctx.fillText(index + 1, x - 5, canvas.height - padding + 15);
        });

        // Line plot with color-coded labels and strike-through for opposite direction
        ctx.beginPath();
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 2;

        graphData.forEach((interval, index) => {
          const x = padding + (index * ((canvas.width - padding * 2) / graphData.length));
          const y = canvas.height - (interval / maxInterval * (canvas.height - padding * 2));

          // Move/line
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        // Draw labels after the line to ensure they are on top
        graphData.forEach((interval, index) => {
          const x = padding + (index * ((canvas.width - padding * 2) / graphData.length));
          const y = canvas.height - (interval / maxInterval * (canvas.height - padding * 2));

          // Color choice
          if (interval < 10) {
            ctx.fillStyle = "red";
          } else if (interval > 25) {
            ctx.fillStyle = "orange";
          } else {
            ctx.fillStyle = "black";
          }

          const label = `${interval.toFixed(0)}ms`;

          // Strike-through if opposite direction
          const globalIdx = index; // graphData aligns to intervals 0..len-3
          ctx.save();
          ctx.strokeStyle = ctx.fillStyle; // match strike color with text color
          if (this.isOppositeInterval(globalIdx)) {
            this.drawStrikethroughText(label, x - 12, y - 6);
          } else {
            ctx.fillText(label, x - 12, y - 6);
          }
          ctx.restore();
        });
      }
    }

    new ScrollTracker();
  </script>
</body>
</html>


